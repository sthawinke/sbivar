% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sbivarSingle.R
\name{sbivarSingle}
\alias{sbivarSingle}
\title{Apply one or more tests for bivariate spatial association}
\usage{
sbivarSingle(
  X,
  Y,
  Cx,
  Ey,
  method = c("GAMs", "Modified t-test", "GPs"),
  n_points_grid = 500,
  mapToFinest = FALSE,
  families = list(X = gaussian(), Y = gaussian()),
  GPmethod = c("REML", "ML", "gpytorch"),
  device = c("cpu", "cuda"),
  training_iter = 100L,
  gpParams,
  Quants = c(0.005, 0.5),
  numLscAlts = 10,
  optControl = lmeControl(opt = "optim", maxIter = 500, msMaxIter = 500, niterEM = 1000,
    msMaxEval = 1000),
  corStruct = corGaus(form = ~x + y, nugget = TRUE, value = c(1, 0.25))
)
}
\arguments{
\item{X, Y}{Matrices of omics measurements}

\item{Cx, Ey}{Corresponding coordinate matrices of dimension two}

\item{method}{A character string, indicating which method to apply}

\item{n_points_grid}{The number of points in the new grid for the GAMs to be
evaluated on.}

\item{mapToFinest}{A boolean, should the one-to-one mapping for modified t-test
occur to the dataset with the best resolution?}

\item{families}{A vector of length 2 giving outcome values.}

\item{GPmethod}{The method by which to fit the Gaussian processes,
passed onto \link[nlme]{gls} as "method" if it equals "REML" or "ML".}

\item{device}{Device to fit the GPs on. Defaults to "cpu",
can use "gpu" via the python package gpytorch if installed}

\item{training_iter}{Number of training iterations in gpytorch}

\item{gpParams}{Parameters of the Gaussian processes, see details}

\item{Quants}{Most extreme quantiles of the distance distribution to take as lenght scales}

\item{numLscAlts}{Number of length scales to be tested for bivariate association}

\item{optControl}{List of control values, see \link[nlme]{glsControl}}

\item{corStruct}{The correlation object, see \link[nlme]{corStruct}.
At this point, only \link[nlme]{corGaus} is accepted}
}
\value{
A matrix which contains at least a p-values ("pVal") and a Benjamini-Hochberg adjusted p-value ("pAdj"),
sorted by increasing p-value.
}
\description{
The tests can be applied to either disjoint or joint coordinate sets.
}
\details{
If only Cx is supplied and X and Y have the same number of rows, a joint analysis is performed
If Cx and Ey are provided, and X and Y have the same number of rows, equality of Cx and Ey is checked.
If true, a joint analysis is run, with a warning.

Any normalization of the data should happen prior to calling this function.
For instance, count data or metabolome data are best scaled to relative values and log-normalized prior to fitting GPs.

gpParams must be a list of length 2 with names 'X' and 'Y', consisting of matrices
with rownames "mean", "nugget", "range" and "sigma", and column names as in X and Y.
This argument allows to pass parameters of the Gaussian processes estimated with other software
to perform the score test.
}
\examples{
n=8e1;m=1e2;p=4;k=5
X = matrix(rnorm(n*p), n, p, dimnames = list(NULL, paste0("X", seq_len(p))))
Y = matrix(rnorm(m*k), m, k, dimnames = list(NULL, paste0("Y", seq_len(k))))
Cx = matrix(runif(n*2), n, 2)
Ey = matrix(runif(m*2), m, 2)
colnames(Cx) = colnames(Ey) = c("x", "y")
resGAMs = sbivarSingle(X, Y, Cx, Ey, method = "GAMs")
resModtTest = sbivarSingle(X, Y, Cx, Ey, method = "Modified")
resModtTestJoint = sbivarSingle(X, Y[seq_len(nrow(X)),], Cx, method = "Modified")
resModtGPs = sbivarSingle(X, Y, Cx, Ey, method = "GPs")
}
