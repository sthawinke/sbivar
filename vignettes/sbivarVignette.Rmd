---
title: "Vignette of the sbivar package"
author: Stijn Hawinkel
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    keep_md: true
    citation_package: biblatex
vignette: >
  %\VignetteIndexEntry{Vignette of the sbivar package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib 
---

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../inst/Sbivar.png"),
               style = 'position:absolute; top:0; right:0; padding:8px;',
               alt = 'logo', width = "280px", heigth = "200px")
```

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(fig.heigh = 7, fig.width = 7)
```

# Introduction

This vignette demonstrates the use of the _sbivar_ package: Spatial BIVARiate association tests.

\setcounter{tocdepth}{5}
\tableofcontents

# Installation instructions

The package can be installed from Bioconductor as follows:

```{r install, eval = FALSE}
library(BiocManager)
install("sbivar")
```

Alternatively, the latest version can be installed from github as:

```{r installAndLoadGitHub, eval = FALSE}
library(devtools)
install_github("sthawinke/sbivar", buildVignettes = TRUE)
```

The _sbivar_ package depends on the _smoppix_ package of the same author of at least version 1.1.8, which can be installed as:

```{r installSmoppix, eval = FALSE}
install_github("sthawinke/smoppix")
```

Once installed, we can load the package:

```{r load}
library(sbivar)
```

# Multithreading

The _sbivar_ package can be computationally intensive, since the number of bivariate tests equals the product of the numbers of features of both modalities. For this reason we provide multithreading through the _BiocParallel_ package. 

```{r}
library(BiocParallel)
```

All the user needs to do, is choose the number of cores: 

```{r}
nCores <- 2 # The number of CPUs
```

and prepare the parallel backend. The code is different for windows or unix-based systems, but is taken care of by the following code snippet:

```{r nonwindows}
if(.Platform$OS.type == "unix"){
    #On unix-based systems, use MulticoreParam
    register(MulticoreParam(nCores))
} else {
    #On windows, use makeCluster
    library(doParallel)
    Clus = makeCluster(nCores)
    registerDoParallel(Clus)
    register(DoparParam(), default = TRUE)
}
```

Wherever applicable, the registered backend will be used throughout the analysis.
For serial calculations, for instance if memory is limiting, choose instead

```{r , eval = FALSE}
register(SerialParam())
```

# Data analysis

## Data exploration

As example dataset, we use the one by @Vicari2024, which includes replicated measurements of spatial transcriptomics and metabolomics coprofiled on mouse brain sections. A subset of the data is available in the _sbivar_ package and can be loaded as:

```{r}
data(Vicari)
names(Vicari)
```

This object consists of four lists of length six: _TranscriptCoords_ and _MetaboliteCoords_ for the coordinates, and _TranscriptOutcomes_ and _MetaboliteOutcomes_ for the feature measurements. Only the 10 most abundant features per modality are included in the package. The metabolite measurements were augmented by a pseudocount of 10$^{-8}$ to avoid zeroes. The _sbivar_ package assumes that the data have been pre-aligned. Yet it is always a good idea to check the alignment visually:

```{r, fig.height = 7}
par(mfrow = c(2,3))
plotCoordsMulti(Vicari$TranscriptCoords, Vicari$MetaboliteCoords, cex = 0.25)
par(mfrow = c(1,1))
```

The alignment seems successful, notice that some tissue areas are only covered by one modality though.

## Single-image analysis

The Vicari data consist of six images which are best analysed jointly, but for didactical purposes we also analyse a single image here, the sample "V11L12-109_A1".

```{r}
singleSample = "V11L12-109_A1"
singleStxCoords = Vicari$TranscriptCoords[[singleSample]]
singleStx = Vicari$TranscriptOutcomes[[singleSample]]
singleMetCoords = Vicari$MetaboliteCoords[[singleSample]]
singleMet = Vicari$MetaboliteOutcomes[[singleSample]]
```

We analyse this single sample using generalized additive models (GAMs), with a negative binomial outcome distribution for the transcriptome data, and a gamma outcome distribution for the metabolome data. A log-link is used in both cases.

```{r}
FamiliesViari = list("X" = mgcv::nb(), "Y" = Gamma(lin = "log"))
gamRes = sbivar(singleStx, singleMet, singleStxCoords, singleMetCoords, 
                      method = "GAMs",  families = FamiliesViari)
```

Have a look at the results, which are sorted by increasing p-value:

```{r}
head(gamRes$result)
```

Plot the most significantly spatially associated gene-metabolite pair `r gpGam <- rownames(gamRes$result)[1]`:

```{r, fig.height = 4.5}
plotTopPair(gamRes, X = singleStx, Y = singleMet, Cx = singleStxCoords, 
            Ey = singleMetCoords)
```

We see a clear negative relationship. We can also plot the corresponding spline fit, with the contributions to the correlation `r round(gamRes$result[gpGam, "corxy"], 3)`:

```{r}
plotGAMsTopResults(gamRes, X = singleStx, Y = singleMet, Cx = singleStxCoords, 
                   Ey = singleMetCoords, families = FamiliesViari)
```

Another available analysis is the modified t-test by @Clifford1989 after sample matching:

```{r civModT}
modTRes = sbivar(singleStx, singleMet, singleStxCoords, singleMetCoords, 
                      method = "Modified t-test")
head(modTRes$result)
```

Finally, also Gaussian processes (GPs) can be applied to single images. Yet fitting GPs and calculating the score tests statistics can be computation and memory intensive! Hence the code is shown, but not run:

```{r gp, eval = FALSE}
gpRes = sbivar(singleStx, singleMet, singleStxCoords, singleMetCoords, 
               method = "GPs")
head(gpRes$result)
```

The analysis results can be written to an external spreadsheet using the following one-liner

```{r sbivarSingleOut, eval = FALSE}
writeSbivarToXlsx(modTRes, file = "myfile.xlsx")
```

## Multi-image analysis

Next, we analyse the six images jointly. Let's look at their names:

```{r namesVic}
names(Vicari$TranscriptOutcomes)
```

We see that the first three and the last three are replicates from different mice (V11L12-109 and V11T16-085). We construct a variable identifying the mouse, consisting of the first 10 characters of the names:

```{r mouseVariable}
mouse = substr(names(Vicari$TranscriptOutcomes), 1, 10)
```

For the multi-image case, we can also use bivariate Moran's I as measure of spatial association, with weights of the weight matrix decaying with distance:

```{r multiMoran}
multiMoranRes = sbivar(Vicari$TranscriptOutcomes, Vicari$MetaboliteOutcomes, 
                            Vicari$TranscriptCoords, Vicari$MetaboliteCoords, 
                            method = "Moran", wo = "distance")
```

Next we plug the calculated Moran's I values into a linear model, with random effects for the individual mice:

```{r multiLmms}
design = data.frame("mouse" = mouse)
multiMoranLmms = fitLinModels(multiMoranRes, design, Formula = ~ (1|mouse))
```

Extract the results and show the results for the intercept, i.e. the overall effect

```{r extractMulti}
multiMoranLmmsRes = extractResultsMulti(multiMoranLmms, design)
head(multiMoranLmmsRes$result$Intercept)
```

No features are significantly associated after multiplicity correction. This is in part caused by different experimental parameters used for the different sections, i.e. these are not real replicates yet, as technology is still being developed. For illustration, we plot the feature pair with the smallest p-values nevertheless:

```{r plottopMulti, fig.height = 9}
plotTopPair(multiMoranLmmsRes, 
    Xl = Vicari$TranscriptOutcomes, Yl = Vicari$MetaboliteOutcomes, 
    Cxl = Vicari$TranscriptCoords, Eyl = Vicari$MetaboliteCoords, size = 0.4)
```

Again, the results of the multi-image analysis can be written to an external spreadsheet. Setting _sigLevel_ to 1 means all feature pairs are written to the file:

```{r sbivarMultiOut, eval = FALSE}
writeSbivarToXlsx(multiMoranLmmsRes, file = "myfile2.xlsx", sigLevel = 1)
```

## SpatialExperiment and MultiAssayExperiment as inputs

The [SpatialExperiment](https://doi.org/doi:10.18129/B9.bioc.SpatialExperiment) and [MultiAssayExperiment](https://doi.org/doi:10.18129/B9.bioc.MultiAssayExperiment) classes are used in Bioconductor to store spatial (multi) omics experiments. The _sbivar_ package provides functionality for doing analysis on these objects directly, for the general case of disjoint coordinate sets between the modalities. 

### Single-image

For illustration, we first construct _SpatialExperiment_ objects for the single-image case:

```{r SEConstruct, message=FALSE}
library(SpatialExperiment, quietly = TRUE)
StxSE = SpatialExperiment(assays = list("transcripts" = t(singleStx)), 
                          spatialCoords = singleStxCoords)
MetSE = SpatialExperiment(assays = list("metabolites" = t(singleMet)), 
                          spatialCoords = singleMetCoords)
```

Look at the first object:

```{r}
StxSE
```

Next we call the _sbivar_ function with these as arguments, providing the names of the assays we want analysed:

```{r SEanalysis}
resSpatExp = sbivar(StxSE, MetSE, assayX = "transcripts", assayY = "metabolites", 
                    families = FamiliesViari, method = "GAMs")
```

Plot the second most significant result, again providing the _SpatialExperiment_ objects

```{r plotTopSE}
plotTopPair(resSpatExp, X = StxSE, Y = MetSE, topRank = 2)
```

Now we construct a _MultiAssayExperiment_ object

```{r makeMAE}
library(MultiAssayExperiment)
MAE = MultiAssayExperiment(experiments = list("transcripts" = StxSE, 
                                              "metabolites" = MetSE))
MAE
```

We run a the same analysis, now providing the experiment names on top of the assay names (since a _MultiAssayExperiment_ can contain more than two modalities):

```{r analyseMAE}
resMAE = sbivar(MAE, assayX = "transcripts", assayY = "metabolites", 
                experimentX = "transcripts", experimentY = "metabolites", 
                families = FamiliesViari, method = "GAM")
```

### Multi-image

For the multi-image case, there are several options. One is to provide a list of _SpatialExperiment_ objects to the _sbivar_ function. We construct such list here for illustrative purposes:

```{r multiListSE}
StxSElist = lapply(selfName(names(Vicari$TranscriptOutcomes)), function(nam){
    SpatialExperiment(assays = list("transcripts" = t(Vicari$TranscriptOutcomes[[nam]])),
                      spatialCoords = Vicari$TranscriptCoords[[nam]])
})
MetSElist = lapply(selfName(names(Vicari$MetaboliteOutcomes)), function(nam){
    SpatialExperiment(assays = list("metabolites" = t(Vicari$MetaboliteOutcomes[[nam]])),
                      spatialCoords = Vicari$MetaboliteCoords[[nam]])
})
multiMoranResSE = sbivar(X = StxSElist, Y = MetSElist, assayX = "transcripts", 
                         assayY = "metabolites", method = "Moran", wo = "distance")
multiMoranLmmsSE = fitLinModels(multiMoranResSE, design, Formula = ~ (1|mouse))
multiMoranLmmsResSE = extractResultsMulti(multiMoranLmmsSE, design)
head(multiMoranLmmsResSE$result$Intercept)
```

As expected, this yields the same result as before with list input.

Another option is to provide only two _SpatialExperiment_ objects, but provide a _sample_id_ argument that identifies the different images. For illustration, we construct such objects from the Vicari data.

```{r SEidentifier}
SEsingleStx = SpatialExperiment(
    assays = list("transcripts" = t(Reduce(Vicari$TranscriptOutcomes, f = rbind))), 
    spatialCoords = Reduce(Vicari$TranscriptCoords, f = rbind), 
    colData = data.frame("sample_id" = rep(names(Vicari$TranscriptOutcomes), 
            times = vapply(Vicari$TranscriptOutcomes, FUN.VALUE = 0L, nrow))))
SEsingleMet = SpatialExperiment(
    assays = list("metabolites" = t(Reduce(Vicari$MetaboliteOutcomes, f = rbind))), 
    spatialCoords = Reduce(Vicari$MetaboliteCoords, f = rbind), 
    colData = data.frame("sample_id" = rep(names(Vicari$MetaboliteOutcomes), 
            times = vapply(Vicari$MetaboliteOutcomes, FUN.VALUE = 0L, nrow))))
```

A quick look:

```{r singleStxLook}
SEsingleStx
```

And run the same analysis:

```{r singleSEanalysis}
sbivarMultiSingleSE = sbivar(SEsingleStx, SEsingleMet, sample_id_x = "sample_id",
                             assayX = "transcripts", assayY = "metabolites", 
                             method = "Correlation")
multiMoranLmmsSingleSE = fitLinModels(sbivarMultiSingleSE, design, 
                                      Formula = ~ (1|mouse))
multiMoranLmmsResSingleSE = extractResultsMulti(multiMoranLmmsSingleSE, design)
```

# Troubleshooting

An error like 

> Error in reducer$value.cache[[as.character(idx)]] <- values : 
>  wrong args for environment subassignment
> In addition: Warning message:
> In parallel::mccollect(wait = FALSE, timeout = 1) :
>  1 parallel job did not deliver a result

often indicates insufficient memory. Try reducing the number of cores requested with _MultiCoreParam()_,
or switch to serial processing with _register(SerialParam())_.
 
# Session info

```{r sessionInfo}
sessionInfo()
```

# Bibliography

\printbibliography 
