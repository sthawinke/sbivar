---
title: "Vignette of the sbivar package"
author: Stijn Hawinkel
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    keep_md: true
    citation_package: biblatex
vignette: >
  %\VignetteIndexEntry{Vignette of the sbivar package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ../inst/REFERENCES.bib 
---

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("../inst/Sbivar.png"),
               style = 'position:absolute; top:0; right:0; padding:10px;',
               alt = 'logo', width = "200px", heigth = "200px")
```

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(fig.heigh = 7, fig.width = 7)
```

# Introduction

This vignette demonstrates the use of the _sbivar_ package: Spatial BIVARiate association tests.

\setcounter{tocdepth}{5}
\tableofcontents

# Installation instructions

The package can be installed from Bioconductor as follows:

```{r install, eval = FALSE}
library(Biocmanager)
install("sbivar")
```

Alternatively, the latest version can be installed from github as:

```{r installAndLoadGitHub, eval = FALSE}
library(devtools)
install_github("sthawinke/sbivar")
```

Once installed, we can load the package:

```{r load}
library(sbivar)
```

# Multithreading

The _sbivar_ package can be computationally intensive, since the number of bivariate tests equals the product of the numbers of features in both modalities. For this reason we provide multithreading through the _BiocParallel_ package. 

```{r}
library(BiocParallel)
```

All the user needs to do, is choose the number of cores: 

```{r}
nCores <- 2 # The number of CPUs
```

and prepare the parallel backend. The code is different for windows or unix-based systems, but is taken care of by the following code snippet:

```{r nonwindows}
if(.Platform$OS.type == "unix"){
    #On unix-based systems, use MulticoreParam
    register(MulticoreParam(nCores))
} else {
    #On windows, use makeCluster
    library(doParallel)
    Clus = makeCluster(nCores)
    registerDoParallel(Clus)
    register(DoparParam(), default = TRUE)
}
```

Wherever applicable, the registered backend will be used throughout the analysis.
For serial calculations, for instance if memory is limiting, choose

```{r , eval = FALSE}
register(SerialParam())
```

# Data analysis

## Data exploration

As example dataset, we load the one by @Vicari2024, which includes replicated measurements of spatial transcriptomics and metabolomics coprofiled on mouse brain sections. A subset of the data is available in the _sbivar_ package and can be loaded as:

```{r}
data(Vicari)
names(Vicari)
```

This object consists of four lists of length six: _MetaboliteCoords_ and _TranscriptCoords_ for the coordinates, and _TranscriptOutcomes_ and _MetaboliteOutcomes_ for the feature measurements. Only the 10 most abundant features per modality are included in the package The Metabolite measurements were augmented by a pseudocount of 10$^{-8}$ to avoid zeroes. It is always a good idea to check the alignment of the coordinates:

```{r}
par(mfrow = c(2,3))
plotCoordsMulti(Vicari$TranscriptCoords, Vicari$MetaboliteCoords, cex = 0.5)
par(mfrow = c(1,1))
```

The alignment seems successful, notice that some tissue areas are only covered by one modality though.

## Single image analysis

The Vicari data consist of six image which are best analysed jointly, but for didactical purposes we also analyse a single image here, the sample "V11L12-109_A1".

```{r}
singleSample = "V11L12-109_A1"
singleStxCoords = Vicari$TranscriptCoords[[singleSample]]
singleStx = Vicari$TranscriptOutcomes[[singleSample]]
singleMetCoords = Vicari$MetaboliteCoords[[singleSample]]
singleMet = Vicari$MetaboliteOutcomes[[singleSample]]
```

Now analyse this single sample using generalized additive models (GAMs), with a negative binomial outcome distribution for the transcriptome data, and a gamma outcome distribution for the metabolome data. A log-link is used in both cases.

```{r}
gamRes = sbivarSingle(singleStx, singleMet, singleStxCoords, singleMetCoords, 
                      method = "GAMs", families = list("X" = mgcv::nb(), "Y" = Gamma(lin = "log")))
```

Have a look at the results:

```{r}
head(gamRes)
```

Plot the most significantly spatially associated gene-metabolite pair `r gpGam <- rownames(gamRes)[1]`:

```{r}
plotTopResultsSingle(gamRes, singleStx, singleMet, singleStxCoords, singleMetCoords)
```

We can also plot the corresponding spline fit, with the contributions to the correlation `r round(gamRes[gpGam, "corxy"], 3)`:

```{r}
plotGAMsTopResults(gamRes, singleStx, singleMet, singleStxCoords, singleMetCoords)
```

Another available analysis is the modified t-test after sample matching:

```{r}
modTRes = sbivarSingle(singleStx, singleMet, singleStxCoords, singleMetCoords, 
                      method = "Modified t-test")
head(modTRes)
```

Plot the top result:

```{r}
plotTopResultsSingle(modTRes, singleStx, singleMet, singleStxCoords, singleMetCoords)
```

Finally, also Gaussian processes (GPs) can be applied to single images. Yet fitting GPs and calculating the score tests statistics can be computation and memory intensive!

```{r gp, eval = FALSE}
gpRes = sbivarSingle(singleStx, singleMet, singleStxCoords, singleMetCoords, 
                      method = "GPs")
head(gpRes)
```

## Multi-image analysis

Next, we analyse the six images jointly. Let's look at their names:

```{r}
names(Vicari$TranscriptOutcomes)
```

We see that the first three and the last three are replicates from different mice (V11L12-109 and V11T16-085). We construct a variable identifying the mouse, consisting of the first 10 characters os the names:

```{r}
mouse = vapply(names(Vicari$TranscriptOutcomes), FUN.VALUE = character(1), function(x) substr(x,1, 10))
```

For the multi-image case, we can also use bivariate Moran's I as measure of spatial association, with weights of the weight matrix decaying with distance:

```{r}
multiMoranRes = sbivarMulti(Xl = Vicari$TranscriptOutcomes, Yl = Vicari$MetaboliteOutcomes, 
                            Cxl = Vicari$TranscriptCoords, Eyl = Vicari$MetaboliteCoords, 
                            method = "Moran", wo = "distance")
```

Next we plug the calculated Moran's I values into a linear model, with random effects for the individual mice:

```{r}
design = data.frame("mouse" = mouse)
multiMoranLmms = fitLinModels(multiMoranRes, design, Formula = ~ (1|mouse))
```

Extract the results for the desired parameter (the intercept)

```{r}
multiMoranLmmsRes  = extractResultsMulti(multiMoranLmms, design)$Intercept
head(multiMoranLmmsRes)
```

No features are significantly associated after multiplicity correction. This is in part caused by different experimental parameters used for the different sections, i.e. these are not real replicates yet, as technology is still being developed.

# Troubleshooting

An error like 

> Error in reducer$value.cache[[as.character(idx)]] <- values : 
>  wrong args for environment subassignment
> In addition: Warning message:
> In parallel::mccollect(wait = FALSE, timeout = 1) :
>  1 parallel job did not deliver a result

often indicates insufficient memory. Try reducing the number of cores requested with _MultiCoreParam()_,
or switch to serial processing with _register(SerialParam())_.
 
# Session info

```{r sessionInfo}
sessionInfo()
```

# Bibliography

\printbibliography 
